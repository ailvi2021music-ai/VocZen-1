<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>VocZen</title>
  <meta name="apple-mobile-web-app-title" content="VocZen">
  <meta name="theme-color" content="#111111" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body{
      margin:0;
      font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      background:#0b0b0c; color:#fff;
      -webkit-text-size-adjust:100%;
    }
    .page{ min-height:100svh; display:flex; align-items:center; justify-content:center; padding:16px; }
    .wrap{ width:100%; max-width:560px; }
    .card{
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:16px;
      padding:16px;
      backdrop-filter: blur(10px);
    }
    .word{
      font-size:30px; font-weight:700;
      margin:10px 0 6px;
      word-break: break-word; line-height:1.15;
    }
    .hint{ opacity:0.7; font-size:13px; }
    .grid{ display:grid; gap:10px; margin-top:12px; }
    .btn{
      appearance:none; width:100%;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.08);
      color:#fff; font-size:16px;
      text-align:left; cursor:pointer;
      user-select:none; word-break: break-word;
      touch-action: manipulation;
    }
    .btn:active{ transform:scale(0.99); }
    .btn:disabled{ opacity:0.6; cursor:not-allowed; }

    .row{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:12px; align-items:center;
    }
    .smallbtn{
      appearance:none;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.08);
      color:#fff; font-size:14px;
      cursor:pointer;
      white-space:nowrap;
      touch-action: manipulation;
    }
    .smallbtn:active{ transform:scale(0.99); }
    .smallbtn:disabled{ opacity:0.45; cursor:not-allowed; }

    .iconbtn{
      width:44px;
      text-align:center;
      font-size:18px;
      line-height:1;
      padding:10px 0;
    }

    .modeToggle{
      width:44px; height:38px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:0;
      cursor:pointer;
      touch-action: manipulation;
      position:relative;
    }
    .modeDots{ display:flex; gap:10px; align-items:center; justify-content:center; }
    .dot{
      width:8px; height:8px;
      border-radius:999px;
      background:rgba(255,255,255,0.25);
      border:1px solid rgba(255,255,255,0.10);
    }
    .dot.on{
      background:rgba(255,255,255,0.85);
      border-color:rgba(255,255,255,0.25);
    }
    .modeToggle:active{ transform:scale(0.99); }

    /* –°–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–µ—Å—Ç–∞ */
    .msg{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.10);
      font-size:14px;
      white-space:pre-wrap;
      word-break: break-word;
      display:none; /* –≤–∞–∂–Ω–æ */
    }
    .msg.ok{ border-color: rgba(0,255,0,0.30); }
    .msg.bad{ border-color: rgba(255,0,0,0.30); }

    details{ margin-top:16px; }
    summary{ cursor:pointer; opacity:0.85; touch-action: manipulation; }

    .taWrap{
      margin-top:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.25);
      overflow:hidden;
    }
    textarea{
      width:100%;
      min-height:140px;
      max-height:240px;
      resize:vertical;
      border:none;
      background:transparent;
      color:#fff;
      padding:12px;
      font-size:16px;
      outline:none;
      -webkit-overflow-scrolling: touch;
      display:block;
    }
    textarea[readonly]{ opacity:0.85; }
    .muted{ opacity:0.65; font-size:12px; margin-top:8px; }
  </style>
</head>

<body>
<div class="page">
  <div class="wrap">
    <div class="card">

      <div class="word" id="questionText">‚Äî</div>
      <div class="hint" id="hintText">–ù–∞–∂–º–∏ Ôºã –∏–ª–∏ –¥–æ–±–∞–≤—å –¥–∞–Ω–Ω—ã–µ –≤ —Ä–µ–∑–µ—Ä–≤</div>

      <div class="grid" id="answers"></div>

      <div class="msg" id="msgBox"></div>

      <div class="row">
        <button class="modeToggle" id="modeToggleBtn" type="button" aria-label="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å: —Å–ª–æ–≤–∞ / –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è">
          <span class="modeDots" aria-hidden="true">
            <span class="dot" id="dotLeft"></span>
            <span class="dot" id="dotRight"></span>
          </span>
        </button>

        <button class="smallbtn" id="dirBtn" type="button">EN‚ÜíRU</button>

        <!-- ‚úì = –∑–Ω–∞—é/–∑–∞–º–µ–Ω–∏ -->
        <button class="smallbtn iconbtn" id="knowBtn" type="button" aria-label="–ó–Ω–∞—é (–ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –≤ –≤—ã—É—á–µ–Ω–æ –∏ –∑–∞–º–µ–Ω–∏—Ç—å)">‚úì</button>

        <!-- ‚Ü© = –º–Ω–æ–≥–æ—à–∞–≥–æ–≤—ã–π undo -->
        <button class="smallbtn iconbtn" id="undoBtn" type="button" aria-label="–®–∞–≥ –Ω–∞–∑–∞–¥ (–æ—Ç–º–µ–Ω–∏—Ç—å)">‚Ü©</button>

        <!-- –ò–∫–æ–Ω–∫–∏ –≤–º–µ—Å—Ç–æ —Ç–µ–∫—Å—Ç–∞ -->
        <button class="smallbtn iconbtn" id="newBtn" type="button" aria-label="–ù–æ–≤—ã–µ (–≤–∑—è—Ç—å –∏–∑ —Ä–µ–∑–µ—Ä–≤–∞)">Ôºã</button>
        <button class="smallbtn iconbtn" id="skipBtn" type="button" aria-label="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å">‚ûú</button>
        <button class="smallbtn" id="repeatBtn" type="button">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å</button>
      </div>

      <details open>
        <summary><span id="vaultTitle">–†–µ–∑–µ—Ä–≤</span> <span id="vaultCount">(0)</span></summary>

        <div class="muted" id="vaultHelp">
          –§–æ—Ä–º–∞—Ç: english - —Ä—É—Å—Å–∫–∏–π, –ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ —Å—Ç—Ä–æ–∫—É. –ú–∏–Ω–∏–º—É–º 4 —Å—Ç—Ä–æ–∫–∏.
        </div>

        <div class="taWrap">
          <textarea id="vaultTextarea" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
        </div>

        <div class="row">
          <button class="smallbtn" id="saveVaultBtn" type="button">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        </div>
      </details>

      <details>
        <summary><span id="learnedTitle">–í—ã—É—á–µ–Ω–æ</span> <span id="learnedCount">(0)</span></summary>

        <div class="taWrap">
          <textarea id="learnedTextarea" readonly></textarea>
        </div>

        <div class="row">
          <!-- –∫–æ—Ä–∑–∏–Ω–∞ –≤–º–µ—Å—Ç–æ "–û—á–∏—Å—Ç–∏—Ç—å" -->
          <button class="smallbtn iconbtn" id="clearLearnedBtn" type="button" aria-label="–û—á–∏—Å—Ç–∏—Ç—å –≤—ã—É—á–µ–Ω–æ">üóë</button>
        </div>
      </details>

    </div>
  </div>
</div>

<script>
(() => {
  const LS_APP_MODE = 'vz_mode_v1';     // 'words' | 'sent'
  const LS_DIR      = 'vz_dir_v1';      // 'EN_RU' | 'RU_EN'
  const LS_MIGRATED = 'vz_migrated_v1'; // '1'

  const K = {
    words: { active:'vz_words_active_v1', vault:'vz_words_vault_v1', learned:'vz_words_learned_v1' },
    sent:  { active:'vz_sent_active_v1',  vault:'vz_sent_vault_v1',  learned:'vz_sent_learned_v1'  }
  };

  const OLD_WORDS = { active:'vt_active_v7', vault:'vt_vault_v7', learned:'vt_learned_v7', mode:'vt_mode_v7' };
  const OLD_SENT  = { active:'st_active_v1', vault:'st_vault_v1', learned:'st_learned_v1', mode:'st_mode_v1' };

  const BATCH_SIZE = 10;
  const AUTO_NEXT_MS = 350;

  const elQuestion = document.getElementById('questionText');
  const elHint     = document.getElementById('hintText');
  const elAnswers  = document.getElementById('answers');
  const elMsg      = document.getElementById('msgBox');

  const btnModeToggle = document.getElementById('modeToggleBtn');
  const dotLeft  = document.getElementById('dotLeft');
  const dotRight = document.getElementById('dotRight');

  const btnDir    = document.getElementById('dirBtn');
  const btnKnow   = document.getElementById('knowBtn');
  const btnUndo   = document.getElementById('undoBtn');
  const btnNew    = document.getElementById('newBtn');
  const btnSkip   = document.getElementById('skipBtn');
  const btnRepeat = document.getElementById('repeatBtn');

  const elVaultTitle = document.getElementById('vaultTitle');
  const elVaultHelp  = document.getElementById('vaultHelp');
  const elVaultCount = document.getElementById('vaultCount');
  const taVault      = document.getElementById('vaultTextarea');
  const btnSaveVault = document.getElementById('saveVaultBtn');

  const elLearnedTitle = document.getElementById('learnedTitle');
  const elLearnedCount = document.getElementById('learnedCount');
  const taLearned      = document.getElementById('learnedTextarea');
  const btnClearLearned= document.getElementById('clearLearnedBtn');

  const loadJSON = (k, fallback) => {
    try { const raw = localStorage.getItem(k); if (!raw) return fallback; return JSON.parse(raw); }
    catch { return fallback; }
  };
  const saveJSON = (k, v) => localStorage.setItem(k, JSON.stringify(v));
  const loadStr  = (k, fb) => (localStorage.getItem(k) ?? fb);
  const saveStr  = (k, v) => localStorage.setItem(k, v);

  const norm = (s) => (String(s ?? '').replace(/\s+/g,' ').trim().toLowerCase());
  const pairKey = (p) => norm(p?.a) + '||' + norm(p?.b);

  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  function dedupePairs(pairs) {
    const seen = new Set();
    const out = [];
    let removed = 0;
    for (const p of pairs) {
      if (!p || typeof p.a !== 'string' || typeof p.b !== 'string') continue;
      const a = p.a.trim(), b = p.b.trim();
      if (!a || !b) continue;
      const key = norm(a) + '||' + norm(b);
      if (seen.has(key)) { removed++; continue; }
      seen.add(key);
      out.push({ a, b });
    }
    return { out, removed };
  }

  function splitLine(line) {
    const s = line.trim();
    const seps = [' - ', ' ‚Äî ', ' ‚Äì '];
    for (const sep of seps) {
      const i = s.indexOf(sep);
      if (i > -1) return [s.slice(0,i).trim(), s.slice(i+sep.length).trim()];
    }
    for (const ch of ['‚Äî','‚Äì','-']) {
      const i = s.indexOf(ch);
      if (i > -1) return [s.slice(0,i).trim(), s.slice(i+1).trim()];
    }
    return [s,''];
  }

  function parseTextarea(text) {
    const lines = String(text ?? '').split('\n').map(x => x.trim()).filter(Boolean);
    const pairs = [];
    const bad = [];
    for (const ln of lines) {
      const [a,b] = splitLine(ln);
      if (!a || !b) { bad.push(ln); continue; }
      pairs.push({ a, b });
    }
    return { pairs, badCount: bad.length };
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function pickWrongOptions(pool, correct, n) {
    const seen = new Set([norm(correct)]);
    const out = [];
    for (const x of shuffle(pool.slice())) {
      const k = norm(x);
      if (!k || seen.has(k)) continue;
      seen.add(k);
      out.push(x);
      if (out.length >= n) break;
    }
    return out;
  }

  let appMode = loadStr(LS_APP_MODE, 'words'); // words | sent
  let dirMode = loadStr(LS_DIR, 'EN_RU');      // EN_RU | RU_EN

  const S = {
    words: { active: [], vault: [], learned: [] },
    sent:  { active: [], vault: [], learned: [] }
  };

  // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π —Ü–∏–∫–ª (–±–µ–∑ shuffle —Ä–∞—É–Ω–¥–æ–≤)
  let pos = 0;
  let current = null;
  let lock = false;

  // –ú–Ω–æ–≥–æ—à–∞–≥–æ–≤—ã–π undo: –æ—Ç–¥–µ–ª—å–Ω—ã–π —Å—Ç–µ–∫ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–µ–∂–∏–º–∞
  const undoStacks = { words: [], sent: [] };

  function updateUndoBtn(){
    const stack = undoStacks[appMode];
    btnUndo.disabled = !(stack && stack.length > 0);
  }

  function setMsg(text, kind=''){
    if (!text) {
      elMsg.textContent = '';
      elMsg.classList.remove('ok','bad');
      elMsg.style.display = 'none';
      return;
    }
    elMsg.textContent = text;
    elMsg.classList.remove('ok','bad');
    if (kind) elMsg.classList.add(kind);
    elMsg.style.display = 'block';
  }

  function migrateOnce() {
    if (loadStr(LS_MIGRATED,'0') === '1') return;

    const oldDir = localStorage.getItem(OLD_WORDS.mode);
    if (oldDir === 'EN_RU' || oldDir === 'RU_EN') saveStr(LS_DIR, oldDir);

    const wActive = loadJSON(OLD_WORDS.active, null);
    const wVault  = loadJSON(OLD_WORDS.vault, null);
    const wLearn  = loadJSON(OLD_WORDS.learned, null);

    const anyOldWords = Array.isArray(wActive) || Array.isArray(wVault) || Array.isArray(wLearn);
    if (anyOldWords) {
      const convert = (arr) => (Array.isArray(arr) ? arr
        .filter(x => x && typeof x.en === 'string' && typeof x.ru === 'string')
        .map(x => ({ a: x.en.trim(), b: x.ru.trim() }))
        .filter(x => x.a && x.b) : []);
      if (!localStorage.getItem(K.words.active))  saveJSON(K.words.active,  convert(wActive));
      if (!localStorage.getItem(K.words.vault))   saveJSON(K.words.vault,   convert(wVault));
      if (!localStorage.getItem(K.words.learned)) saveJSON(K.words.learned, convert(wLearn));
    }

    const sActive = loadJSON(OLD_SENT.active, null);
    const sVault  = loadJSON(OLD_SENT.vault, null);
    const sLearn  = loadJSON(OLD_SENT.learned, null);
    const anyOldSent = Array.isArray(sActive) || Array.isArray(sVault) || Array.isArray(sLearn);
    if (anyOldSent) {
      const convert = (arr) => (Array.isArray(arr) ? arr
        .filter(x => x && typeof x.en === 'string' && typeof x.ru === 'string')
        .map(x => ({ a: x.en.trim(), b: x.ru.trim() }))
        .filter(x => x.a && x.b) : []);
      if (!localStorage.getItem(K.sent.active))  saveJSON(K.sent.active,  convert(sActive));
      if (!localStorage.getItem(K.sent.vault))   saveJSON(K.sent.vault,   convert(sVault));
      if (!localStorage.getItem(K.sent.learned)) saveJSON(K.sent.learned, convert(sLearn));
    }

    saveStr(LS_MIGRATED,'1');
  }

  function loadModeData(modeKey) {
    const keys = K[modeKey];
    S[modeKey].active  = loadJSON(keys.active,  []);
    S[modeKey].vault   = loadJSON(keys.vault,   []);
    S[modeKey].learned = loadJSON(keys.learned, []);
    if (!Array.isArray(S[modeKey].active))  S[modeKey].active = [];
    if (!Array.isArray(S[modeKey].vault))   S[modeKey].vault = [];
    if (!Array.isArray(S[modeKey].learned)) S[modeKey].learned = [];
  }

  function saveModeData(modeKey) {
    const keys = K[modeKey];
    saveJSON(keys.active,  S[modeKey].active);
    saveJSON(keys.vault,   S[modeKey].vault);
    saveJSON(keys.learned, S[modeKey].learned);
  }

  function modeLabel(){ return appMode === 'words' ? '–°–ª–æ–≤–∞' : '–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è'; }
  function reserveHelpText(){
    return appMode === 'words'
      ? '–§–æ—Ä–º–∞—Ç: english - —Ä—É—Å—Å–∫–∏–π, –ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ —Å—Ç—Ä–æ–∫—É. –ú–∏–Ω–∏–º—É–º 4 —Å—Ç—Ä–æ–∫–∏.'
      : '–§–æ—Ä–º–∞—Ç: English sentence - –†—É—Å—Å–∫–∏–π —Å–º—ã—Å–ª, –ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ —Å—Ç—Ä–æ–∫—É. –ú–∏–Ω–∏–º—É–º 4 —Å—Ç—Ä–æ–∫–∏.';
  }

  function syncTextareas(){
    const st = S[appMode];
    taVault.value = st.vault.map(x => `${x.a} - ${x.b}`).join('\n');
    taLearned.value = st.learned.map(x => `${x.a} - ${x.b}`).join('\n');

    elVaultCount.textContent = `(${st.vault.length})`;
    elLearnedCount.textContent = `(${st.learned.length})`;
    elVaultTitle.textContent = '–†–µ–∑–µ—Ä–≤';
    elLearnedTitle.textContent = '–í—ã—É—á–µ–Ω–æ';
    elVaultHelp.textContent = reserveHelpText();

    btnDir.textContent = (dirMode === 'EN_RU') ? 'EN‚ÜíRU' : 'RU‚ÜíEN';

    dotLeft.classList.toggle('on', appMode === 'words');
    dotRight.classList.toggle('on', appMode === 'sent');

    updateUndoBtn();
  }

  function buildQuestion(){
    const st = S[appMode];
    if (!current) return null;

    const question = (dirMode === 'EN_RU') ? current.a : current.b;
    const correct  = (dirMode === 'EN_RU') ? current.b : current.a;

    const pool = st.active
      .filter(x => pairKey(x) !== pairKey(current))
      .map(x => (dirMode === 'EN_RU') ? x.b : x.a);

    const wrongs = pickWrongOptions(pool, correct, 3);
    const options = shuffle([correct, ...wrongs]);

    return { question, correct, options };
  }

  function renderTraining(clearMsg=false){
    syncTextareas();
    const st = S[appMode];

    if (!st.active || st.active.length < 4){
      elQuestion.textContent = '‚Äî';
      elHint.textContent = `–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ (${modeLabel()}).`;
      elAnswers.innerHTML = '';
      if (clearMsg) setMsg('');
      return;
    }

    if (!current){
      pos = 0;
      current = st.active[pos];
      if (clearMsg) setMsg('');
    }

    const q = buildQuestion();
    if (!q) return;

    elQuestion.textContent = q.question;
    elHint.textContent = (dirMode === 'EN_RU')
      ? (appMode === 'words' ? '–í—ã–±–µ—Ä–∏ –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ —Ä—É—Å—Å–∫–æ–º' : '–í—ã–±–µ—Ä–∏ —Ä—É—Å—Å–∫–∏–π —Å–º—ã—Å–ª')
      : (appMode === 'words' ? '–í—ã–±–µ—Ä–∏ –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º' : '–í—ã–±–µ—Ä–∏ –∞–Ω–≥–ª–∏–π—Å–∫—É—é —Ñ—Ä–∞–∑—É');

    elAnswers.innerHTML = '';
    lock = false;

    q.options.forEach(opt=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.type = 'button';
      b.textContent = opt;
      b.addEventListener('click', () => onAnswer(opt, q.correct));
      elAnswers.appendChild(b);
    });
  }

  function disableAnswers(disabled){
    [...elAnswers.querySelectorAll('button')].forEach(b=>b.disabled=!!disabled);
  }

  function onAnswer(chosen, correct){
    if (lock) return;
    if (norm(chosen) === norm(correct)){
      lock = true;
      setMsg('–ú–æ–ª–æ–¥–µ—Ü ‚úÖ','ok');
      disableAnswers(true);
      setTimeout(goNext, AUTO_NEXT_MS);
    } else {
      setMsg(`–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ ‚ùå –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π: ${correct}`,'bad');
    }
  }

  // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π —Ü–∏–∫–ª: pos = (pos+1) mod N
  function goNext(){
    const st = S[appMode];
    disableAnswers(false);
    lock = false;

    if (!st.active || st.active.length < 4){
      current = null;
      renderTraining(true);
      return;
    }

    pos = (pos + 1) % st.active.length;
    current = st.active[pos];
    renderTraining(false);
  }

  function saveVaultFromTextarea(){
    const { pairs, badCount } = parseTextarea(taVault.value);
    const { out, removed } = dedupePairs(pairs);
    S[appMode].vault = out;
    saveModeData(appMode);
    syncTextareas();

    let msg = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ ‚úÖ';
    const parts = [];
    if (removed>0) parts.push(`–¥—É–±–ª–µ–π —É–¥–∞–ª–µ–Ω–æ: ${removed}`);
    if (badCount>0) parts.push(`—Å—Ç—Ä–æ–∫ –ø—Ä–æ–ø—É—â–µ–Ω–æ: ${badCount}`);
    if (parts.length) msg += ` (${parts.join(', ')})`;
    setMsg(msg,'ok');
  }

  // –ü–µ—Ä–µ–Ω–æ—Å active -> learned (—Å –¥–µ–¥—É–ø–æ–º)
  function moveActiveToLearned(){
    const st = S[appMode];
    const merged = [...st.learned, ...st.active];
    st.learned = dedupePairs(merged).out;
  }

  // Ôºã –ù–æ–≤—ã–µ: –±–µ–∑–æ–ø–∞—Å–Ω–æ ‚Äî –µ—Å–ª–∏ –∏–∑ —Ä–µ–∑–µ—Ä–≤–∞ < 4, –Ω–∏—á–µ–≥–æ –Ω–µ –ø–µ—Ä–µ–Ω–æ—Å–∏–º –∏ –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
  function takeNewBatchFromVault(){
    const st = S[appMode];

    // —Å–±—Ä–æ—Å undo-–∏—Å—Ç–æ—Ä–∏–∏ –ø—Ä–∏ —Å–º–µ–Ω–µ –Ω–∞–±–æ—Ä–∞
    undoStacks[appMode] = [];

    if (!st.vault || st.vault.length < 4){
      setMsg(`–í —Ä–µ–∑–µ—Ä–≤–µ –º–µ–Ω—å—à–µ 4 —Å—Ç—Ä–æ–∫ (${modeLabel()}). –î–æ–±–∞–≤—å –º–∏–Ω–∏–º—É–º 4.`, 'bad');
      syncTextareas();
      return;
    }

    // –ø–æ–¥–≥–æ—Ç–æ–≤–∏–º –±–∞—Ç—á, –ù–ï —Ç—Ä–æ–≥–∞—è –¥–∞–Ω–Ω—ã–µ, –ø–æ–∫–∞ –Ω–µ —É–≤–µ—Ä–µ–Ω—ã
    const shuffledVault = shuffle(st.vault.slice());
    const take = shuffledVault.slice(0, BATCH_SIZE);
    if (take.length < 4){
      setMsg(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è –Ω–∞–±–æ—Ä–∞ (–Ω—É–∂–Ω–æ 4+).`, 'bad');
      syncTextareas();
      return;
    }

    // —Ç–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –∫–æ–º–º–∏—Ç–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
    if (st.active.length) moveActiveToLearned();

    const takeSet = new Set(take.map(x => pairKey(x)));
    const rest = st.vault.filter(x => !takeSet.has(pairKey(x)));

    st.active = take;
    st.vault = rest;

    saveModeData(appMode);

    pos = 0;
    current = st.active[pos];
    setMsg(`${modeLabel()}: –∑–∞–≥—Ä—É–∂–µ–Ω–æ ${st.active.length} ‚úÖ`,'ok');
    renderTraining(false);
  }

  // ‚úÖ –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê "–ü–û–í–¢–û–†–ò–¢–¨":
  // - —Ä–∞–±–æ—Ç–∞–µ—Ç —Å 1+
  // - –±–µ—Ä—ë—Ç N –∏–∑ "–í—ã—É—á–µ–Ω–æ" (N = min(learned, 10))
  // - –ø–µ—Ä–µ–Ω–æ—Å–∏—Ç –∏—Ö –≤ "–ò–∑—É—á–∞–µ–º—ã–µ"
  // - –≤—ã–º–µ—â–∞–µ—Ç N —Ç–µ–∫—É—â–∏—Ö "–ò–∑—É—á–∞–µ–º—ã—Ö" –≤ "–†–µ–∑–µ—Ä–≤"
  // - —É–¥–∞–ª—è–µ—Ç —ç—Ç–∏ N –∏–∑ "–í—ã—É—á–µ–Ω–æ"
  function takeRepeatFromLearned(){
    const st = S[appMode];

    // —Å–±—Ä–æ—Å undo-–∏—Å—Ç–æ—Ä–∏–∏ (–∫–∞–∫ —É —Ç–µ–±—è –±—ã–ª–æ)
    undoStacks[appMode] = [];

    if (!st.learned || st.learned.length === 0){
      setMsg(`–ù–µ—Ç –≤—ã—É—á–µ–Ω–Ω–æ–≥–æ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–∞ (${modeLabel()}).`, 'bad');
      syncTextareas();
      return;
    }

    // —Å–∫–æ–ª—å–∫–æ —Ö–æ—Ç–∏–º –≤–µ—Ä–Ω—É—Ç—å –Ω–∞ –ø–æ–≤—Ç–æ—Ä
    const wantN = Math.min(st.learned.length, BATCH_SIZE);

    // –∏—Å–∫–ª—é—á–∏–º —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ —á–∞—Å—Ç—å "–≤—ã—É—á–µ–Ω–æ" —É–∂–µ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ active
    const activeKeys = new Set((st.active || []).map(x => pairKey(x)));
    const picked = [];
    const pickedKeys = new Set();

    // —Å–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º –∏–∑ –≤—ã—É—á–µ–Ω–Ω–æ–≥–æ
    const shuffled = shuffle(st.learned.slice());
    for (const item of shuffled) {
      const k = pairKey(item);
      if (!k || pickedKeys.has(k)) continue;
      if (activeKeys.has(k)) continue; // —É–∂–µ –∏–∑—É—á–∞–µ—Ç—Å—è ‚Äî –Ω–µ –±–µ—Ä—ë–º
      picked.push(item);
      pickedKeys.add(k);
      if (picked.length >= wantN) break;
    }

    if (picked.length === 0){
      setMsg(`–í—Å–µ –≤—ã—É—á–µ–Ω–Ω—ã–µ —É–∂–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –∏–∑—É—á–∞–µ–º—ã—Ö (${modeLabel()}).`, 'bad');
      syncTextareas();
      return;
    }

    const n = picked.length;

    // 1) —É–¥–∞–ª—è–µ–º picked –∏–∑ "–í—ã—É—á–µ–Ω–æ"
    st.learned = st.learned.filter(x => !pickedKeys.has(pairKey(x)));

    // 2) –≤—ã–º–µ—â–∞–µ–º n —Ç–µ–∫—É—â–∏—Ö "–ò–∑—É—á–∞–µ–º—ã—Ö" –≤ "–†–µ–∑–µ—Ä–≤"
    //    (–≤—ã–º–µ—â–∞–µ–º —Å –∫–æ–Ω—Ü–∞, —á—Ç–æ–±—ã –º–µ–Ω—å—à–µ —à–∞–Ω—Å —Å–Ω–µ—Å—Ç–∏ "—Ç–µ–∫—É—â–µ–µ" —Å–ª–æ–≤–æ)
    let kicked = [];
    if (Array.isArray(st.active) && st.active.length > 0){
      if (st.active.length >= n) {
        kicked = st.active.splice(st.active.length - n, n);
      } else {
        // –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–µ–Ω—å—à–µ ‚Äî –≤—ã–º–µ—â–∞–µ–º –≤—Å—ë —á—Ç–æ –µ—Å—Ç—å
        kicked = st.active.splice(0, st.active.length);
      }
    } else {
      st.active = [];
    }

    if (kicked.length){
      st.vault = Array.isArray(st.vault) ? st.vault : [];
      st.vault.push(...kicked);
      st.vault = dedupePairs(st.vault).out;
    }

    // 3) –¥–æ–±–∞–≤–ª—è–µ–º picked –≤ "–ò–∑—É—á–∞–µ–º—ã–µ"
    st.active.push(...picked);
    st.active = dedupePairs(st.active).out;

    // 4) –µ—Å–ª–∏ –ø–æ—Å–ª–µ –æ–ø–µ—Ä–∞—Ü–∏–π –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å—Ç–∞–ª–æ <4 ‚Äî —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞ (4 –≤–∞—Ä–∏–∞–Ω—Ç–∞ –æ—Ç–≤–µ—Ç–∞)
    //    –Ω–æ –¥–∞–Ω–Ω—ã–µ –º—ã –ù–ï —Ç–µ—Ä—è–µ–º, –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    saveModeData(appMode);

    // –ø–æ–ø—Ä–∞–≤–∏–º pos/current —Ç–∞–∫, —á—Ç–æ–±—ã –Ω–µ —É–ª–µ—Ç–µ–ª–æ
    if (!st.active || st.active.length === 0){
      pos = 0;
      current = null;
      setMsg(`–ü–æ–≤—Ç–æ—Ä: –¥–æ–±–∞–≤–ª–µ–Ω–æ ${n}. –ù–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–µ—Ç ‚Äî –Ω–∞–∂–º–∏ Ôºã –∏–ª–∏ –¥–æ–±–∞–≤—å —Å–ª–æ–≤–∞.`, 'bad');
      renderTraining(false);
      return;
    }

    if (pos >= st.active.length) pos = 0;
    current = st.active[pos];

    setMsg(`–ü–æ–≤—Ç–æ—Ä: –¥–æ–±–∞–≤–ª–µ–Ω–æ ${n} ‚Üí –∏–∑—É—á–∞–µ–º—ã–µ. –í —Ä–µ–∑–µ—Ä–≤: ${kicked.length}.`, 'ok');
    renderTraining(false);
  }

  function clearLearned(){
    S[appMode].learned = [];
    saveModeData(appMode);
    syncTextareas();
    setMsg('–í—ã—É—á–µ–Ω–æ –æ—á–∏—â–µ–Ω–æ ‚úÖ','ok');
  }

  // ‚úì –ó–Ω–∞—é: –ø–µ—Ä–µ–Ω–æ—Å —Ç–µ–∫—É—â–µ–≥–æ –≤ –≤—ã—É—á–µ–Ω–æ + –∑–∞–º–µ–Ω–∞ –∏–∑ —Ä–µ–∑–µ—Ä–≤–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
  // –°–Ω–∞–ø—à–æ—Ç –≤ —Å—Ç–µ–∫ ‚Äî –º–æ–∂–Ω–æ –æ—Ç–∫–∞—Ç—ã–≤–∞—Ç—å —Å–∫–æ–ª—å–∫–æ —É–≥–æ–¥–Ω–æ —Ä–∞–∑
  function knowAndReplace(){
    const st = S[appMode];
    if (!current || !st.active || st.active.length < 4) return;

    // push snapshot
    undoStacks[appMode].push({
      state: deepClone({ active: st.active, vault: st.vault, learned: st.learned }),
      pos,
      currentKey: pairKey(current)
    });
    updateUndoBtn();

    const curKey = pairKey(current);

    // 1) current -> learned
    st.learned.push({ a: current.a, b: current.b });
    st.learned = dedupePairs(st.learned).out;

    // 2) –Ω–∞–π—Ç–∏ –∏–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ –≤ active (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
    const idx = st.active.findIndex(x => pairKey(x) === curKey);
    const useIdx = idx >= 0 ? idx : pos;

    // 3) –∑–∞–º–µ–Ω–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –Ω–æ–≤—ã–π –∏–∑ —Ä–µ–∑–µ—Ä–≤–∞ (–∏–ª–∏ —É–¥–∞–ª–∏—Ç—å, –µ—Å–ª–∏ —Ä–µ–∑–µ—Ä–≤–∞ –Ω–µ—Ç)
    if (st.vault && st.vault.length > 0) {
      const pick = Math.floor(Math.random() * st.vault.length);
      const replacement = st.vault.splice(pick, 1)[0];
      st.active[useIdx] = replacement; // —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä active –∏ –ø–æ–∑–∏—Ü–∏—é
    } else {
      // –µ—Å–ª–∏ —Ä–µ–∑–µ—Ä–≤ –ø—É—Å—Ç ‚Äî —É–¥–∞–ª—è–µ–º —ç—Ç–æ—Ç —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö
      st.active.splice(useIdx, 1);
      // –ø–æ–ø—Ä–∞–≤–∏—Ç—å pos
      if (st.active.length > 0) pos = useIdx % st.active.length;
      else pos = 0;
    }

    saveModeData(appMode);

    if (!st.active || st.active.length < 4){
      current = null;
      setMsg(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ (${modeLabel()}). –î–æ–±–∞–≤—å –º–∏–Ω–∏–º—É–º 4 —Å—Ç—Ä–æ–∫–∏ –≤ —Ä–µ–∑–µ—Ä–≤.`, 'bad');
      renderTraining(false);
      return;
    }

    current = st.active[pos];
    setMsg('–ì–æ—Ç–æ–≤–æ ‚úÖ','ok');
    renderTraining(false);
  }

  // ‚Ü© –º–Ω–æ–≥–æ—à–∞–≥–æ–≤—ã–π undo
  function undoKnow(){
    const stack = undoStacks[appMode];
    if (!stack || stack.length === 0){
      updateUndoBtn();
      return;
    }

    const snap = stack.pop();
    const st = S[appMode];

    st.active  = deepClone(snap.state.active);
    st.vault   = deepClone(snap.state.vault);
    st.learned = deepClone(snap.state.learned);

    saveModeData(appMode);

    pos = Math.min(Math.max(0, snap.pos ?? 0), Math.max(0, st.active.length - 1));
    current = st.active[pos] || null;

    setMsg('–û—Ç–º–µ–Ω–µ–Ω–æ ‚Ü©','ok');
    updateUndoBtn();
    renderTraining(false);
  }

  btnModeToggle.addEventListener('click', () => {
    appMode = (appMode === 'words') ? 'sent' : 'words';
    saveStr(LS_APP_MODE, appMode);
    pos = 0;
    current = null;
    setMsg('');
    renderTraining(true);
  });

  btnDir.addEventListener('click', () => {
    dirMode = (dirMode === 'EN_RU') ? 'RU_EN' : 'EN_RU';
    saveStr(LS_DIR, dirMode);
    setMsg('');
    renderTraining(false);
  });

  btnSaveVault.addEventListener('click', saveVaultFromTextarea);
  btnNew.addEventListener('click', takeNewBatchFromVault);
  btnRepeat.addEventListener('click', takeRepeatFromLearned);

  btnSkip.addEventListener('click', () => {
    setMsg('');
    goNext();
  });

  btnClearLearned.addEventListener('click', clearLearned);

  btnKnow.addEventListener('click', knowAndReplace);
  btnUndo.addEventListener('click', undoKnow);

  // init
  migrateOnce();
  loadModeData('words');
  loadModeData('sent');

  syncTextareas();
  updateUndoBtn();
  renderTraining(true);
})();
</script>
</body>
</html>
