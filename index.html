<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>VocZen</title>
  <meta name="apple-mobile-web-app-title" content="VocZen">
  <meta name="theme-color" content="#111111" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body{
      margin:0;
      font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      background:#0b0b0c; color:#fff;
      -webkit-text-size-adjust:100%;
    }
    .page{ min-height:100svh; display:flex; align-items:center; justify-content:center; padding:16px; }
    .wrap{ width:100%; max-width:560px; }
    .card{
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:16px;
      padding:16px;
      backdrop-filter: blur(10px);
    }
    .word{
      font-size:30px; font-weight:700;
      margin:10px 0 6px;
      word-break: break-word; line-height:1.15;
    }
    .hint{ opacity:0.7; font-size:13px; }
    .grid{ display:grid; gap:10px; margin-top:12px; }
    .btn{
      appearance:none; width:100%;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.08);
      color:#fff; font-size:16px;
      text-align:left; cursor:pointer;
      user-select:none; word-break: break-word;
      touch-action: manipulation;
    }
    .btn:active{ transform:scale(0.99); }
    .btn:disabled{ opacity:0.6; cursor:not-allowed; }

    .row{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:12px; align-items:center;
    }
    .smallbtn{
      appearance:none;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.08);
      color:#fff; font-size:14px;
      cursor:pointer;
      white-space:nowrap;
      touch-action: manipulation;
    }
    .smallbtn:active{ transform:scale(0.99); }
    .smallbtn:disabled{ opacity:0.45; cursor:not-allowed; }

    .iconbtn{
      width:44px;
      text-align:center;
      line-height:1;
      padding:10px 0;
      font-size:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:0;
    }

    /* Единый стиль иконок (SVG) на всех устройствах */
    .iconbtn svg{
      width:18px;
      height:18px;
      stroke:rgba(255,255,255,0.92);
      fill:none;
      stroke-width:2.2;
      stroke-linecap:round;
      stroke-linejoin:round;
    }
    .smallbtn:disabled svg{
      stroke:rgba(255,255,255,0.45);
    }

    .modeToggle{
      width:44px; height:38px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:0;
      cursor:pointer;
      touch-action: manipulation;
      position:relative;
    }
    .modeDots{ display:flex; gap:10px; align-items:center; justify-content:center; }
    .dot{
      width:8px; height:8px;
      border-radius:999px;
      background:rgba(255,255,255,0.25);
      border:1px solid rgba(255,255,255,0.10);
    }
    .dot.on{
      background:rgba(255,255,255,0.85);
      border-color:rgba(255,255,255,0.25);
    }
    .modeToggle:active{ transform:scale(0.99); }

    /* Сообщение без зарезервированного места */
    .msg{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.10);
      font-size:14px;
      white-space:pre-wrap;
      word-break: break-word;
      display:none; /* важно */
    }
    .msg.ok{ border-color: rgba(0,255,0,0.30); }
    .msg.bad{ border-color: rgba(255,0,0,0.30); }

    details{ margin-top:16px; }
    summary{ cursor:pointer; opacity:0.85; touch-action: manipulation; }

    .taWrap{
      margin-top:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.25);
      overflow:hidden;
    }
    textarea{
      width:100%;
      min-height:140px;
      max-height:240px;
      resize:vertical;
      border:none;
      background:transparent;
      color:#fff;
      padding:12px;
      font-size:16px;
      outline:none;
      -webkit-overflow-scrolling: touch;
      display:block;
    }
    textarea[readonly]{ opacity:0.85; }
    .muted{ opacity:0.65; font-size:12px; margin-top:8px; }
  </style>
</head>

<body>
<div class="page">
  <div class="wrap">
    <div class="card">

      <div class="word" id="questionText">—</div>
      <div class="hint" id="hintText">Нажми ＋ или добавь данные в резерв</div>

      <div class="grid" id="answers"></div>

      <div class="msg" id="msgBox"></div>

      <div class="row">
        <button class="modeToggle" id="modeToggleBtn" type="button" aria-label="Переключить: слова / предложения">
          <span class="modeDots" aria-hidden="true">
            <span class="dot" id="dotLeft"></span>
            <span class="dot" id="dotRight"></span>
          </span>
        </button>

        <button class="smallbtn" id="dirBtn" type="button">EN→RU</button>

        <!-- ✓ = знаю/замени -->
        <button class="smallbtn iconbtn" id="knowBtn" type="button" aria-label="Знаю (перенести в выучено и заменить)">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M20 6L9 17l-5-5"></path>
          </svg>
        </button>

        <!-- ↩ = многошаговый undo -->
        <button class="smallbtn iconbtn" id="undoBtn" type="button" aria-label="Шаг назад (отменить)">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M9 14l-4-4 4-4"></path>
            <path d="M5 10h9a5 5 0 1 1 0 10h-2"></path>
          </svg>
        </button>

        <!-- ＋ -->
        <button class="smallbtn iconbtn" id="newBtn" type="button" aria-label="Новые (взять из резерва)">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 5v14"></path>
            <path d="M5 12h14"></path>
          </svg>
        </button>

        <!-- ➜ -->
        <button class="smallbtn iconbtn" id="skipBtn" type="button" aria-label="Пропустить">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M5 12h12"></path>
            <path d="M13 6l6 6-6 6"></path>
          </svg>
        </button>

        <!-- ⟳ (повторить) -->
        <button class="smallbtn iconbtn" id="repeatBtn" type="button" aria-label="Повторить">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M20 12a8 8 0 1 1-2.34-5.66"></path>
            <path d="M20 4v6h-6"></path>
          </svg>
        </button>
      </div>

      <details open>
        <summary><span id="vaultTitle">Резерв</span> <span id="vaultCount">(0)</span></summary>

        <div class="muted" id="vaultHelp">
          Формат: english - русский, по одному на строку. Минимум 4 строки.
        </div>

        <div class="taWrap">
          <textarea id="vaultTextarea" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
        </div>

        <div class="row">
          <button class="smallbtn" id="saveVaultBtn" type="button">Сохранить</button>
        </div>
      </details>

      <details>
        <summary><span id="learnedTitle">Выучено</span> <span id="learnedCount">(0)</span></summary>

        <div class="taWrap">
          <textarea id="learnedTextarea" readonly></textarea>
        </div>

        <div class="row">
          <!-- корзина -->
          <button class="smallbtn iconbtn" id="clearLearnedBtn" type="button" aria-label="Очистить выучено">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M3 6h18"></path>
              <path d="M8 6V4h8v2"></path>
              <path d="M6 6l1 16h10l1-16"></path>
              <path d="M10 11v6"></path>
              <path d="M14 11v6"></path>
            </svg>
          </button>
        </div>
      </details>

    </div>
  </div>
</div>

<script>
(() => {
  const LS_APP_MODE = 'vz_mode_v1';     // 'words' | 'sent'
  const LS_DIR      = 'vz_dir_v1';      // 'EN_RU' | 'RU_EN'
  const LS_MIGRATED = 'vz_migrated_v1'; // '1'

  const K = {
    words: { active:'vz_words_active_v1', vault:'vz_words_vault_v1', learned:'vz_words_learned_v1' },
    sent:  { active:'vz_sent_active_v1',  vault:'vz_sent_vault_v1',  learned:'vz_sent_learned_v1'  }
  };

  const OLD_WORDS = { active:'vt_active_v7', vault:'vt_vault_v7', learned:'vt_learned_v7', mode:'vt_mode_v7' };
  const OLD_SENT  = { active:'st_active_v1', vault:'st_vault_v1', learned:'st_learned_v1', mode:'st_mode_v1' };

  const BATCH_SIZE = 10;
  const AUTO_NEXT_MS = 350;

  const elQuestion = document.getElementById('questionText');
  const elHint     = document.getElementById('hintText');
  const elAnswers  = document.getElementById('answers');
  const elMsg      = document.getElementById('msgBox');

  const btnModeToggle = document.getElementById('modeToggleBtn');
  const dotLeft  = document.getElementById('dotLeft');
  const dotRight = document.getElementById('dotRight');

  const btnDir    = document.getElementById('dirBtn');
  const btnKnow   = document.getElementById('knowBtn');
  const btnUndo   = document.getElementById('undoBtn');
  const btnNew    = document.getElementById('newBtn');
  const btnSkip   = document.getElementById('skipBtn');
  const btnRepeat = document.getElementById('repeatBtn');

  const elVaultTitle = document.getElementById('vaultTitle');
  const elVaultHelp  = document.getElementById('vaultHelp');
  const elVaultCount = document.getElementById('vaultCount');
  const taVault      = document.getElementById('vaultTextarea');
  const btnSaveVault = document.getElementById('saveVaultBtn');

  const elLearnedTitle = document.getElementById('learnedTitle');
  const elLearnedCount = document.getElementById('learnedCount');
  const taLearned      = document.getElementById('learnedTextarea');
  const btnClearLearned= document.getElementById('clearLearnedBtn');

  const loadJSON = (k, fallback) => {
    try { const raw = localStorage.getItem(k); if (!raw) return fallback; return JSON.parse(raw); }
    catch { return fallback; }
  };
  const saveJSON = (k, v) => localStorage.setItem(k, JSON.stringify(v));
  const loadStr  = (k, fb) => (localStorage.getItem(k) ?? fb);
  const saveStr  = (k, v) => localStorage.setItem(k, v);

  const norm = (s) => (String(s ?? '').replace(/\s+/g,' ').trim().toLowerCase());
  const pairKey = (p) => norm(p?.a) + '||' + norm(p?.b);

  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  function dedupePairs(pairs) {
    const seen = new Set();
    const out = [];
    let removed = 0;
    for (const p of pairs) {
      if (!p || typeof p.a !== 'string' || typeof p.b !== 'string') continue;
      const a = p.a.trim(), b = p.b.trim();
      if (!a || !b) continue;
      const key = norm(a) + '||' + norm(b);
      if (seen.has(key)) { removed++; continue; }
      seen.add(key);
      out.push({ a, b });
    }
    return { out, removed };
  }

  function splitLine(line) {
    const s = line.trim();
    const seps = [' - ', ' — ', ' – '];
    for (const sep of seps) {
      const i = s.indexOf(sep);
      if (i > -1) return [s.slice(0,i).trim(), s.slice(i+sep.length).trim()];
    }
    for (const ch of ['—','–','-']) {
      const i = s.indexOf(ch);
      if (i > -1) return [s.slice(0,i).trim(), s.slice(i+1).trim()];
    }
    return [s,''];
  }

  function parseTextarea(text) {
    const lines = String(text ?? '').split('\n').map(x => x.trim()).filter(Boolean);
    const pairs = [];
    const bad = [];
    for (const ln of lines) {
      const [a,b] = splitLine(ln);
      if (!a || !b) { bad.push(ln); continue; }
      pairs.push({ a, b });
    }
    return { pairs, badCount: bad.length };
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function pickWrongOptions(pool, correct, n) {
    const seen = new Set([norm(correct)]);
    const out = [];
    for (const x of shuffle(pool.slice())) {
      const k = norm(x);
      if (!k || seen.has(k)) continue;
      seen.add(k);
      out.push(x);
      if (out.length >= n) break;
    }
    return out;
  }

  let appMode = loadStr(LS_APP_MODE, 'words'); // words | sent
  let dirMode = loadStr(LS_DIR, 'EN_RU');      // EN_RU | RU_EN

  const S = {
    words: { active: [], vault: [], learned: [] },
    sent:  { active: [], vault: [], learned: [] }
  };

  // Последовательный цикл (без shuffle раундов)
  let pos = 0;
  let current = null;
  let lock = false;

  // Многошаговый undo: отдельный стек для каждого режима
  const undoStacks = { words: [], sent: [] };

  // Чтобы не затирать несохранённый ввод в резерве
  let vaultDirty = false;

  function updateUndoBtn(){
    const stack = undoStacks[appMode];
    btnUndo.disabled = !(stack && stack.length > 0);
  }

  function setMsg(text, kind=''){
    if (!text) {
      elMsg.textContent = '';
      elMsg.classList.remove('ok','bad');
      elMsg.style.display = 'none';
      return;
    }
    elMsg.textContent = text;
    elMsg.classList.remove('ok','bad');
    if (kind) elMsg.classList.add(kind);
    elMsg.style.display = 'block';
  }

  function migrateOnce() {
    if (loadStr(LS_MIGRATED,'0') === '1') return;

    const oldDir = localStorage.getItem(OLD_WORDS.mode);
    if (oldDir === 'EN_RU' || oldDir === 'RU_EN') saveStr(LS_DIR, oldDir);

    const wActive = loadJSON(OLD_WORDS.active, null);
    const wVault  = loadJSON(OLD_WORDS.vault, null);
    const wLearn  = loadJSON(OLD_WORDS.learned, null);

    const anyOldWords = Array.isArray(wActive) || Array.isArray(wVault) || Array.isArray(wLearn);
    if (anyOldWords) {
      const convert = (arr) => (Array.isArray(arr) ? arr
        .filter(x => x && typeof x.en === 'string' && typeof x.ru === 'string')
        .map(x => ({ a: x.en.trim(), b: x.ru.trim() }))
        .filter(x => x.a && x.b) : []);
      if (!localStorage.getItem(K.words.active))  saveJSON(K.words.active,  convert(wActive));
      if (!localStorage.getItem(K.words.vault))   saveJSON(K.words.vault,   convert(wVault));
      if (!localStorage.getItem(K.words.learned)) saveJSON(K.words.learned, convert(wLearn));
    }

    const sActive = loadJSON(OLD_SENT.active, null);
    const sVault  = loadJSON(OLD_SENT.vault, null);
    const sLearn  = loadJSON(OLD_SENT.learned, null);
    const anyOldSent = Array.isArray(sActive) || Array.isArray(sVault) || Array.isArray(sLearn);
    if (anyOldSent) {
      const convert = (arr) => (Array.isArray(arr) ? arr
        .filter(x => x && typeof x.en === 'string' && typeof x.ru === 'string')
        .map(x => ({ a: x.en.trim(), b: x.ru.trim() }))
        .filter(x => x.a && x.b) : []);
      if (!localStorage.getItem(K.sent.active))  saveJSON(K.sent.active,  convert(sActive));
      if (!localStorage.getItem(K.sent.vault))   saveJSON(K.sent.vault,   convert(sVault));
      if (!localStorage.getItem(K.sent.learned)) saveJSON(K.sent.learned, convert(sLearn));
    }

    saveStr(LS_MIGRATED,'1');
  }

  function loadModeData(modeKey) {
    const keys = K[modeKey];
    S[modeKey].active  = loadJSON(keys.active,  []);
    S[modeKey].vault   = loadJSON(keys.vault,   []);
    S[modeKey].learned = loadJSON(keys.learned, []);
    if (!Array.isArray(S[modeKey].active))  S[modeKey].active = [];
    if (!Array.isArray(S[modeKey].vault))   S[modeKey].vault = [];
    if (!Array.isArray(S[modeKey].learned)) S[modeKey].learned = [];
  }

  function saveModeData(modeKey) {
    const keys = K[modeKey];
    saveJSON(keys.active,  S[modeKey].active);
    saveJSON(keys.vault,   S[modeKey].vault);
    saveJSON(keys.learned, S[modeKey].learned);
  }

  function modeLabel(){ return appMode === 'words' ? 'Слова' : 'Предложения'; }
  function reserveHelpText(){
    return appMode === 'words'
      ? 'Формат: english - русский, по одному на строку. Минимум 4 строки.'
      : 'Формат: English sentence - Русский смысл, по одному на строку. Минимум 4 строки.';
  }

  function syncTextareas(){
    const st = S[appMode];

    // IMPORTANT: не затирать несохранённый ввод
    const vaultFocused = (document.activeElement === taVault);
    if (!vaultDirty && !vaultFocused) {
      taVault.value = st.vault.map(x => `${x.a} - ${x.b}`).join('\n');
    }

    taLearned.value = st.learned.map(x => `${x.a} - ${x.b}`).join('\n');

    elVaultCount.textContent = `(${st.vault.length})`;
    elLearnedCount.textContent = `(${st.learned.length})`;
    elVaultTitle.textContent = 'Резерв';
    elLearnedTitle.textContent = 'Выучено';
    elVaultHelp.textContent = reserveHelpText();

    btnDir.textContent = (dirMode === 'EN_RU') ? 'EN→RU' : 'RU→EN';

    dotLeft.classList.toggle('on', appMode === 'words');
    dotRight.classList.toggle('on', appMode === 'sent');

    updateUndoBtn();
  }

  function buildQuestion(){
    const st = S[appMode];
    if (!current) return null;

    const question = (dirMode === 'EN_RU') ? current.a : current.b;
    const correct  = (dirMode === 'EN_RU') ? current.b : current.a;

    const pool = st.active
      .filter(x => pairKey(x) !== pairKey(current))
      .map(x => (dirMode === 'EN_RU') ? x.b : x.a);

    const wrongs = pickWrongOptions(pool, correct, 3);
    const options = shuffle([correct, ...wrongs]);

    return { question, correct, options };
  }

  function renderTraining(clearMsg=false){
    syncTextareas();
    const st = S[appMode];

    if (!st.active || st.active.length < 4){
      elQuestion.textContent = '—';
      elHint.textContent = `Недостаточно элементов для тренировки (${modeLabel()}).`;
      elAnswers.innerHTML = '';
      if (clearMsg) setMsg('');
      return;
    }

    if (!current){
      pos = 0;
      current = st.active[pos];
      if (clearMsg) setMsg('');
    }

    const q = buildQuestion();
    if (!q) return;

    elQuestion.textContent = q.question;
    elHint.textContent = (dirMode === 'EN_RU')
      ? (appMode === 'words' ? 'Выбери перевод на русском' : 'Выбери русский смысл')
      : (appMode === 'words' ? 'Выбери перевод на английском' : 'Выбери английскую фразу');

    elAnswers.innerHTML = '';
    lock = false;

    q.options.forEach(opt=>{
      const b = document.createElement('button');
      b.className = 'btn';
      b.type = 'button';
      b.textContent = opt;
      b.addEventListener('click', () => onAnswer(opt, q.correct));
      elAnswers.appendChild(b);
    });
  }

  function disableAnswers(disabled){
    [...elAnswers.querySelectorAll('button')].forEach(b=>b.disabled=!!disabled);
  }

  function onAnswer(chosen, correct){
    if (lock) return;
    if (norm(chosen) === norm(correct)){
      lock = true;
      setMsg('Молодец ✅','ok');
      disableAnswers(true);
      setTimeout(goNext, AUTO_NEXT_MS);
    } else {
      setMsg(`Неправильно ❌ Правильный: ${correct}`,'bad');
    }
  }

  // Последовательный цикл: pos = (pos+1) mod N
  function goNext(){
    // ВАЖНО: сообщение (Молодец/ошибка) должно исчезать при переходе к следующему элементу
    setMsg('');

    const st = S[appMode];
    disableAnswers(false);
    lock = false;

    if (!st.active || st.active.length < 4){
      current = null;
      renderTraining(true);
      return;
    }

    pos = (pos + 1) % st.active.length;
    current = st.active[pos];
    renderTraining(false);
  }

  function saveVaultFromTextarea(){
    const { pairs, badCount } = parseTextarea(taVault.value);
    const { out, removed } = dedupePairs(pairs);
    S[appMode].vault = out;
    saveModeData(appMode);

    vaultDirty = false; // теперь ввод сохранён

    syncTextareas();

    let msg = 'Сохранено ✅';
    const parts = [];
    if (removed>0) parts.push(`дублей удалено: ${removed}`);
    if (badCount>0) parts.push(`строк пропущено: ${badCount}`);
    if (parts.length) msg += ` (${parts.join(', ')})`;
    setMsg(msg,'ok');
  }

  // Перенос active -> learned (с дедупом)
  function moveActiveToLearned(){
    const st = S[appMode];
    const merged = [...st.learned, ...st.active];
    st.learned = dedupePairs(merged).out;
  }

  // ＋ Новые: НЕ ДОЛЖНО стирать несохранённый ввод при ошибке
  function takeNewBatchFromVault(){
    const st = S[appMode];

    // сброс undo-истории при смене набора
    undoStacks[appMode] = [];
    updateUndoBtn();

    if (!st.vault || st.vault.length < 4){
      setMsg(`В резерве меньше 4 строк (${modeLabel()}). Добавь минимум 4 и нажми «Сохранить».`, 'bad');
      // НЕ вызываем syncTextareas() здесь, чтобы не стереть введённый, но не сохранённый текст
      return;
    }

    const shuffledVault = shuffle(st.vault.slice());
    const take = shuffledVault.slice(0, BATCH_SIZE);
    if (take.length < 4){
      setMsg(`Недостаточно для набора (нужно 4+).`, 'bad');
      return;
    }

    if (st.active.length) moveActiveToLearned();

    const takeSet = new Set(take.map(x => pairKey(x)));
    const rest = st.vault.filter(x => !takeSet.has(pairKey(x)));

    st.active = take;
    st.vault = rest;

    saveModeData(appMode);

    pos = 0;
    current = st.active[pos];
    setMsg(`${modeLabel()}: загружено ${st.active.length} ✅`,'ok');
    renderTraining(false);
  }

  // Повторить: НЕ ДОЛЖНО стирать несохранённый ввод при ошибке
  function takeRepeatFromLearned(){
    const st = S[appMode];

    undoStacks[appMode] = [];
    updateUndoBtn();

    if (!st.learned || st.learned.length < 1){
      setMsg(`Нет выученного для повтора (${modeLabel()}).`, 'bad');
      return;
    }

    // берём до 10, но допускаем и 1..3
    const shuffled = shuffle(st.learned.slice());
    const take = shuffled.slice(0, Math.min(BATCH_SIZE, shuffled.length));
    if (take.length < 1){
      setMsg(`Нет выученного для повтора (${modeLabel()}).`, 'bad');
      return;
    }

    // Коммит: чтобы ничего не терялось —
    // take (из learned) -> active,
    // а столько же текущих active -> vault.
    const takeSet = new Set(take.map(x => pairKey(x)));
    const restLearned = st.learned.filter(x => !takeSet.has(pairKey(x)));

    const count = take.length;

    const displaced = st.active.slice(0, count); // вытесняем первые N из активных
    const newActive = take.concat(st.active.slice(count));

    // displaced -> vault (с дедупом вместе)
    st.vault = dedupePairs(st.vault.concat(displaced)).out;

    st.active = newActive;
    st.learned = restLearned;

    saveModeData(appMode);

    pos = 0;
    current = st.active[pos] || null;
    setMsg(`Повтор: загружено ${take.length} ✅`,'ok');
    renderTraining(false);
  }

  function clearLearned(){
    S[appMode].learned = [];
    saveModeData(appMode);
    syncTextareas();
    setMsg('Выучено очищено ✅','ok');
  }

  // ✓ Знаю: перенос текущего в выучено + замена из резерва (если есть)
  function knowAndReplace(){
    const st = S[appMode];
    if (!current || !st.active || st.active.length < 1) return;

    // snapshot
    undoStacks[appMode].push({
      state: deepClone({ active: st.active, vault: st.vault, learned: st.learned }),
      pos,
      currentKey: pairKey(current)
    });
    updateUndoBtn();

    const curKey = pairKey(current);

    // 1) current -> learned
    st.learned.push({ a: current.a, b: current.b });
    st.learned = dedupePairs(st.learned).out;

    // 2) индекс текущего в active
    const idx = st.active.findIndex(x => pairKey(x) === curKey);
    const useIdx = idx >= 0 ? idx : pos;

    // 3) заменить элемент на новый из резерва (или удалить, если резерва нет)
    if (st.vault && st.vault.length > 0) {
      const pick = Math.floor(Math.random() * st.vault.length);
      const replacement = st.vault.splice(pick, 1)[0];
      st.active[useIdx] = replacement;
    } else {
      st.active.splice(useIdx, 1);
      if (st.active.length > 0) pos = useIdx % st.active.length;
      else pos = 0;
    }

    saveModeData(appMode);

    if (!st.active || st.active.length < 4){
      current = null;
      setMsg(`Недостаточно элементов для тренировки (${modeLabel()}). Добавь минимум 4 строки в резерв.`, 'bad');
      renderTraining(false);
      return;
    }

    current = st.active[pos];
    setMsg('Готово ✅','ok');
    renderTraining(false);
  }

  // ↩ многошаговый undo
  function undoKnow(){
    const stack = undoStacks[appMode];
    if (!stack || stack.length === 0){
      updateUndoBtn();
      return;
    }

    const snap = stack.pop();
    const st = S[appMode];

    st.active  = deepClone(snap.state.active);
    st.vault   = deepClone(snap.state.vault);
    st.learned = deepClone(snap.state.learned);

    saveModeData(appMode);

    pos = Math.min(Math.max(0, snap.pos ?? 0), Math.max(0, st.active.length - 1));
    current = st.active[pos] || null;

    setMsg('Отменено ↩','ok');
    updateUndoBtn();
    renderTraining(false);
  }

  btnModeToggle.addEventListener('click', () => {
    appMode = (appMode === 'words') ? 'sent' : 'words';
    saveStr(LS_APP_MODE, appMode);
    pos = 0;
    current = null;
    setMsg('');
    renderTraining(true);
  });

  btnDir.addEventListener('click', () => {
    dirMode = (dirMode === 'EN_RU') ? 'RU_EN' : 'EN_RU';
    saveStr(LS_DIR, dirMode);
    setMsg('');
    renderTraining(false);
  });

  btnSaveVault.addEventListener('click', saveVaultFromTextarea);
  btnNew.addEventListener('click', takeNewBatchFromVault);
  btnRepeat.addEventListener('click', takeRepeatFromLearned);

  btnSkip.addEventListener('click', () => {
    setMsg('');
    goNext();
  });

  btnClearLearned.addEventListener('click', clearLearned);

  btnKnow.addEventListener('click', knowAndReplace);
  btnUndo.addEventListener('click', undoKnow);

  taVault.addEventListener('input', () => {
    vaultDirty = true;
  });

  // init
  migrateOnce();
  loadModeData('words');
  loadModeData('sent');

  syncTextareas();
  updateUndoBtn();
  renderTraining(true);
})();
</script>
</body>
</html>
